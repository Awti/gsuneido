// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

// Copyright Suneido Software Corp. All rights reserved.
// Governed by the MIT license found in the LICENSE file.

package meta

import (
	"sort"

	"github.com/apmckinlay/gsuneido/database/db19/stor"
	"github.com/apmckinlay/gsuneido/util/verify"
)

// list returns a list of the keys in the table
func (ht SchemaHamt) list() []string {
	keys := make([]string, 0, 16)
	ht.ForEach(func(it *Schema) {
		keys = append(keys, SchemaKey(it))
	})
	return keys
}

const blockSizeSchema = 2000
const perFingerSchema = 16

func (ht SchemaHamt) Write(st *stor.Stor) uint64 {
	nitems := 0
	size := 2
	ht.ForEach(func(it *Schema) {
		size += it.storSize()
		nitems++
	})
	if nitems == 0 {
		off, buf := st.Alloc(2)
		stor.NewWriter(buf).Put2(0)
		return off
	}
	nfingers := 1 + nitems/perFingerSchema
	size += 3 * nfingers
	off, buf := st.Alloc(size)
	w := stor.NewWriter(buf)
	w.Put2(nitems)

	keys := ht.list()
	sort.Strings(keys)
	w2 := *w
	for i := 0; i < nfingers; i++ {
		w.Put3(0) // leave room
	}
	fingers := make([]int, 0, nfingers)
	for i, k := range keys {
		if i%16 == 0 {
			fingers = append(fingers, w.Len())
		}
		it, _ := ht.Get(k)
		it.Write(w)
	}
	verify.That(len(fingers) == nfingers)
	for _, f := range fingers {
		w2.Put3(f) // update with actual values
	}
	return off
}

func ReadSchemaHamt(st *stor.Stor, off uint64) SchemaHamt {
	r := st.Reader(off)
	nitems := r.Get2()
	t := SchemaHamt{}.Mutable()
	if nitems == 0 {
		return t
	}
	nfingers := 1 + nitems/perFingerSchema
	for i := 0; i < nfingers; i++ {
		r.Get3() // skip the fingers
	}
	for i := 0; i < nitems; i++ {
		t.Put(ReadSchema(st, r))
	}
	return t.Freeze()
}

//-------------------------------------------------------------------

type SchemaPacked struct {
	stor    *stor.Stor
	off     uint64
	buf     []byte
	fingers []SchemaFinger
}

type SchemaFinger struct {
	table string
	pos   int
}

func NewSchemaPacked(st *stor.Stor, off uint64) *SchemaPacked {
	buf := st.Data(off)
	r := stor.NewReader(buf)
	nitems := r.Get2()
	nfingers := 1 + nitems/perFingerSchema
	fingers := make([]SchemaFinger, nfingers)
	for i := 0; i < nfingers; i++ {
		fingers[i].pos = r.Get3()
	}
	for i := 0; i < nfingers; i++ {
		fingers[i].table = stor.NewReader(buf[fingers[i].pos:]).GetStr()
	}
	return &SchemaPacked{stor: st, off: off, buf: buf, fingers: fingers}
}

func (p SchemaPacked) Get(key string) *Schema {
	pos := p.binarySearch(key)
	r := stor.NewReader(p.buf[pos:])
	count := 0
	for {
		item := ReadSchema(p.stor, r)
		if item.Table == key {
			return item
		}
		count++
		if count > 20 {
			panic("linear search too long")
		}
	}
}

// binarySearch does a binary search of the fingers
func (p SchemaPacked) binarySearch(table string) int {
	i, j := 0, len(p.fingers)
	count := 0
	for i < j {
		h := int(uint(i+j) >> 1) // i â‰¤ h < j
		if table >= p.fingers[h].table {
			i = h + 1
		} else {
			j = h
		}
		count++
		if count > 20 {
			panic("binary search too long")
		}
	}
	// i is first one greater, so we want i-1
	return int(p.fingers[i-1].pos)
}

func (p SchemaPacked) Offset() uint64 {
	return p.off
}
