// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

// Copyright Suneido Software Corp. All rights reserved.
// Governed by the MIT license found in the LICENSE file.

package testflathash

import "math/bits"

type PairHtbl struct {
	slots []*Pair
	// nitems is the current number of key/values in the map
	nitems int
	// cap is the limit for nitems before resizing
	cap int
	// shift is used by hashToIndex
	shift int
	// mask is used to wrap around
	mask int
}

// NewPairHtbl creates a new PairHtbl with roughly the specified capacity
func NewPairHtbl(cap int) *PairHtbl {
	const loadPercent = 70
	if cap < 9 {
		cap = 9
	}
	size, shift := nextPow2(cap * 100 / loadPercent)
	return &PairHtbl{slots: make([]*Pair, size),
		shift: shift, mask: size - 1, cap: size * loadPercent / 100}
}

func nextPow2(n int) (int, int) {
	bl := bits.Len(uint(n))
	return 1 << bl, 32 - bl
}

func (h *PairHtbl) Put(item *Pair) {
	if h.nitems >= h.cap {
		h.grow()
	}
	key := h.keyOf(item)
	for i := h.hashToIndex(h.hash(key)); ; i = (i + 1) & h.mask {
		if h.slots[i] == nil {
			h.nitems++
		} else if h.keyOf(h.slots[i]) != key {
			continue
		}
		h.slots[i] = item
		return
	}
}

func (h *PairHtbl) Get(key int) *Pair {
	for i := h.hashToIndex(h.hash(key)); ; i = (i + 1) & h.mask {
		if h.slots[i] == nil {
			return nil
		}
		if key == h.keyOf(h.slots[i]) {
			return h.slots[i]
		}
	}
}

func (h *PairHtbl) hashToIndex(hash uint32) int {
	const phi32 = 2654435769
	x := (hash * phi32)
	return int(x >> h.shift)
}

func (h *PairHtbl) grow() {
	old := *h
	h.cap *= 2
	h.shift--
	h.mask = h.mask<<1 + 1
	h.nitems = 0
	h.slots = make([]*Pair, 2*len(old.slots))
	for _, slot := range old.slots {
		if slot != nil {
			h.Put(slot)
		}
	}
	if h.nitems != old.nitems {
		panic("flathash grow failed")
	}
}

func (h *PairHtbl) Dup() *PairHtbl {
	h2 := *h
	h2.slots = append([]*Pair(nil), h.slots...)
	return &h2
}

func (h *PairHtbl) List() []int {
	keys := make([]int, h.nitems, 0)
	for _, slot := range h.slots {
		if slot != nil {
			keys = append(keys, h.keyOf(slot))
		}
	}
	if len(keys) != h.nitems {
		panic("flathash Ints failed")
	}
	return keys
}

func (h *PairHtbl) Iter() func() *Pair {
	i := 0
	return func() *Pair {
		for ; i < len(h.slots); i++ {
			if h.slots[i] != nil {
				return h.slots[i]
			}
		}
		return nil // end
	}
}
